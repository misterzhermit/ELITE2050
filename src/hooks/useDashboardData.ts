import React from 'react';
import { useGame } from '../store/GameContext';
import { calculateTeamPower } from '../engine/gameLogic';
import { LeagueState } from '../types';
import {
    MAX_TEAM_POWER_TIER_1,
    MAX_TEAM_POWER_TIER_2,
    MAX_TEAM_POWER_TIER_3,
    SEASON_DAYS
} from '../constants/gameConstants';

export const useDashboardData = () => {
    const { state } = useGame();

    const userManager = state.userManagerId ? state.managers[state.userManagerId] : null;
    const userTeam = userManager?.career.currentTeamId ? state.teams[userManager.career.currentTeamId] : null;

    const baseDate = new Date(state.world.currentDate || new Date().toISOString());
    const seasonStartReal = state.world.seasonStartReal ? new Date(state.world.seasonStartReal) : null;

    // gameDate is now exactly baseDate (1:1 Sync)
    const gameDate = baseDate;

    const totalPoints = userTeam ? calculateTeamPower(userTeam, state.players) : 0;

    // Determine power cap: prioritize team's persistent powerCap, then fall back to tier-based base values
    const powerCap = React.useMemo(() => {
        if (!userTeam) return MAX_TEAM_POWER_TIER_1;

        // If team has a dynamic/persistent cap, use it
        if (userTeam.powerCap !== undefined) return userTeam.powerCap;

        // Cyan (Elite) = 12k, Orange/Purple (Mid) = 10k, Green (Low) = 8k
        if (userTeam.league === 'Cyan') return MAX_TEAM_POWER_TIER_1;
        if (userTeam.league === 'Orange' || userTeam.league === 'Purple') return MAX_TEAM_POWER_TIER_2;
        return MAX_TEAM_POWER_TIER_3;
    }, [userTeam]);

    const pointsLeft = powerCap - totalPoints;

    const seasonDaysTotal = SEASON_DAYS;
    const msPerDay = 1000 * 60 * 60 * 24;

    let daysPassed = 0;
    let seasonProgress = 0;

    if (seasonStartReal) {
        const diffMs = baseDate.getTime() - seasonStartReal.getTime();
        if (diffMs > 0) {
            daysPassed = Math.floor(diffMs / msPerDay) + 1;
            seasonProgress = Math.min(100, Math.round((daysPassed / seasonDaysTotal) * 100));
        } else {
            // Day 0
            daysPassed = 0;
            seasonProgress = 0;
        }
    }

    const userTeamMatches = React.useMemo(() => {
        if (!userTeam || !state.world?.leagues) return [];

        const leagues = Object.values(state.world.leagues) as LeagueState[];
        const userLeague = leagues.find(l => l.standings.some(s => s.teamId === userTeam.id));

        if (!userLeague || !userLeague.matches) return [];

        const currentRound = state.world.currentRound;
        const matches = userLeague.matches
            .filter(m => (m.homeTeamId === userTeam.id || m.awayTeamId === userTeam.id))
            .sort((a, b) => a.round - b.round);

        return matches.map(m => {
            const homeTeam = state.teams[m.homeTeamId];
            const awayTeam = state.teams[m.awayTeamId];

            // Use the date and time already stored on the match object
            // (generated by CalendarGenerator relative to seasonStartReal)
            const matchDate = m.date.split('T')[0];
            const matchTime = m.time || '16:00';

            return {
                id: m.id,
                round: m.round,
                date: matchDate,
                time: matchTime,
                home: homeTeam?.name || 'Unknown',
                away: awayTeam?.name || 'Unknown',
                homeId: m.homeTeamId,
                awayId: m.awayTeamId,
                homeLogo: homeTeam?.logo,
                awayLogo: awayTeam?.logo,
                homeScore: m.homeScore,
                awayScore: m.awayScore,
                played: m.played,
                result: m.result,
                type: 'League'
            };
        });
    }, [userTeam, state.world.leagues, state.world.currentRound, state.teams, state.world.currentDate]);

    const upcomingMatches = React.useMemo(() => {
        return userTeamMatches.filter(m => !m.played);
    }, [userTeamMatches]);

    const pastMatches = React.useMemo(() => {
        return userTeamMatches.filter(m => m.played);
    }, [userTeamMatches]);

    const leaguesData = React.useMemo(() => {
        if (!state.world?.leagues) return {};

        const processLeague = (league: LeagueState) => {
            const sortedStandings = [...league.standings].sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                const gdA = a.goalsFor - a.goalsAgainst;
                const gdB = b.goalsFor - b.goalsAgainst;
                return gdB - gdA;
            });

            const formattedStandings = sortedStandings.map((stats, index) => ({
                position: index + 1,
                team: state.teams[stats.teamId]?.name || 'Unknown',
                logo: state.teams[stats.teamId]?.logo,
                played: stats.played,
                points: stats.points,
                gd: stats.goalsFor - stats.goalsAgainst,
                id: stats.teamId
            }));

            const leaguePlayers: { name: string; team: string; goals: number; rank: number }[] = [];
            league.standings.forEach(teamStats => {
                const team = state.teams[teamStats.teamId];
                if (team && team.squad) {
                    team.squad.forEach(playerId => {
                        const player = state.players[playerId];
                        if (player && player.history?.goals > 0) {
                            leaguePlayers.push({
                                name: player.name,
                                team: team.name,
                                goals: player.history.goals,
                                rank: 0
                            });
                        }
                    });
                }
            });

            const sortedScorers = leaguePlayers
                .sort((a, b) => b.goals - a.goals)
                .slice(0, 10)
                .map((p, i) => ({ ...p, rank: i + 1 }));

            return {
                name: league.name,
                standings: formattedStandings,
                scorers: sortedScorers
            };
        };

        const processedLeagues: Record<string, any> = {};
        Object.keys(state.world.leagues).forEach(key => {
            if (state.world.leagues[key]) {
                processedLeagues[key] = processLeague(state.world.leagues[key] as LeagueState);
            }
        });
        return processedLeagues;
    }, [state.world, state.teams, state.players]);

    return {
        userManager,
        userTeam,
        baseDate,
        gameDate,
        totalPoints,
        powerCap,
        pointsLeft,
        seasonProgress,
        daysPassed,
        userTeamMatches,
        upcomingMatches,
        pastMatches,
        leaguesData
    };
};
